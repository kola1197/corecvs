#ifndef SCANNER_PARAMETERS_H_
#define SCANNER_PARAMETERS_H_
/**
 * \file scannerParameters.h
 * \attention This file is automatically generated and should not be in general modified manually
 *
 * \date MMM DD, 20YY
 * \author autoGenerator
 * Generated from scanner.xml
 */

#include "core/reflection/reflection.h"
#include "core/reflection/defaultSetter.h"
#include "core/reflection/printerVisitor.h"

/*
 *  Embed includes.
 */
/*
 *  Additional includes for Composite Types.
 */

// using namespace corecvs;

/*
 *  Additional includes for Pointer Types.
 */

// namespace corecvs {
// }
/*
 *  Additional includes for enum section.
 */
#include "core/xml/generated/imageChannel.h"
#include "core/xml/generated/redRemovalType.h"

/**
 * \brief Scanner parameters 
 * Scanner parameters 
 **/
class ScannerParameters : public corecvs::BaseReflection<ScannerParameters>
{
public:
    enum FieldId {
        CHANNEL_ID,
        ALGO_ID,
        RED_THRESHOLD_ID,
        HEIGHT_ID,
        GRAPH_LINE_ID,
        USE_SSE_ID,
        CALCULATE_CONVOLUTION_ID,
        CALIBRATIONMODE_ID,
        CORNER_SCORE_ID,
        HARRIS_APPERTURE_ID,
        SCANNER_PARAMETERS_FIELD_ID_NUM
    };

    /** Section with variables */

    /** 
     * \brief channel 
     * channel 
     */
    int mChannel;

    /** 
     * \brief algo 
     * algo 
     */
    int mAlgo;

    /** 
     * \brief red threshold 
     * red threshold 
     */
    int mRedThreshold;

    /** 
     * \brief height 
     * height 
     */
    double mHeight;

    /** 
     * \brief Graph line 
     * Graph line 
     */
    int mGraphLine;

    /** 
     * \brief Use SSE 
     * Use SSE 
     */
    bool mUseSSE;

    /** 
     * \brief Calculate convolution 
     * Calculate convolution 
     */
    bool mCalculateConvolution;

    /** 
     * \brief CalibrationMode 
     * CalibrationMode 
     */
    bool mCalibrationMode;

    /** 
     * \brief Corner Score 
     * Corner Score 
     */
    double mCornerScore;

    /** 
     * \brief Harris Apperture 
     * Harris Apperture 
     */
    int mHarrisApperture;

    /** Static fields init function, this is used for "dynamic" field initialization */ 
    static int staticInit(corecvs::Reflection *toFill);

    static int relinkCompositeFields();

    /** Section with getters */
    const void *getPtrById(int fieldId) const
    {
        return (const unsigned char *)(this) + fields()[fieldId]->offset;
    }
    ImageChannel::ImageChannel channel() const
    {
        return static_cast<ImageChannel::ImageChannel>(mChannel);
    }

    RedRemovalType::RedRemovalType algo() const
    {
        return static_cast<RedRemovalType::RedRemovalType>(mAlgo);
    }

    int redThreshold() const
    {
        return mRedThreshold;
    }

    double height() const
    {
        return mHeight;
    }

    int graphLine() const
    {
        return mGraphLine;
    }

    bool useSSE() const
    {
        return mUseSSE;
    }

    bool calculateConvolution() const
    {
        return mCalculateConvolution;
    }

    bool calibrationMode() const
    {
        return mCalibrationMode;
    }

    double cornerScore() const
    {
        return mCornerScore;
    }

    int harrisApperture() const
    {
        return mHarrisApperture;
    }

    /* Section with setters */
    void setChannel(ImageChannel::ImageChannel channel)
    {
        mChannel = channel;
    }

    void setAlgo(RedRemovalType::RedRemovalType algo)
    {
        mAlgo = algo;
    }

    void setRedThreshold(int redThreshold)
    {
        mRedThreshold = redThreshold;
    }

    void setHeight(double height)
    {
        mHeight = height;
    }

    void setGraphLine(int graphLine)
    {
        mGraphLine = graphLine;
    }

    void setUseSSE(bool useSSE)
    {
        mUseSSE = useSSE;
    }

    void setCalculateConvolution(bool calculateConvolution)
    {
        mCalculateConvolution = calculateConvolution;
    }

    void setCalibrationMode(bool calibrationMode)
    {
        mCalibrationMode = calibrationMode;
    }

    void setCornerScore(double cornerScore)
    {
        mCornerScore = cornerScore;
    }

    void setHarrisApperture(int harrisApperture)
    {
        mHarrisApperture = harrisApperture;
    }

    /* Section with embedded classes */
    /* visitor pattern - http://en.wikipedia.org/wiki/Visitor_pattern */
template<class VisitorType>
    void accept(VisitorType &visitor)
    {
        visitor.visit((int &)mChannel,            static_cast<const corecvs::EnumField *>(fields()[CHANNEL_ID]));
        visitor.visit((int &)mAlgo,               static_cast<const corecvs::EnumField *>(fields()[ALGO_ID]));
        visitor.visit(mRedThreshold,              static_cast<const corecvs::IntField *>(fields()[RED_THRESHOLD_ID]));
        visitor.visit(mHeight,                    static_cast<const corecvs::DoubleField *>(fields()[HEIGHT_ID]));
        visitor.visit(mGraphLine,                 static_cast<const corecvs::IntField *>(fields()[GRAPH_LINE_ID]));
        visitor.visit(mUseSSE,                    static_cast<const corecvs::BoolField *>(fields()[USE_SSE_ID]));
        visitor.visit(mCalculateConvolution,      static_cast<const corecvs::BoolField *>(fields()[CALCULATE_CONVOLUTION_ID]));
        visitor.visit(mCalibrationMode,           static_cast<const corecvs::BoolField *>(fields()[CALIBRATIONMODE_ID]));
        visitor.visit(mCornerScore,               static_cast<const corecvs::DoubleField *>(fields()[CORNER_SCORE_ID]));
        visitor.visit(mHarrisApperture,           static_cast<const corecvs::IntField *>(fields()[HARRIS_APPERTURE_ID]));
    }

    ScannerParameters()
    {
        corecvs::DefaultSetter setter;
        accept(setter);
    }

    ScannerParameters(
          ImageChannel::ImageChannel channel
        , RedRemovalType::RedRemovalType algo
        , int redThreshold
        , double height
        , int graphLine
        , bool useSSE
        , bool calculateConvolution
        , bool calibrationMode
        , double cornerScore
        , int harrisApperture
    )
    {
        mChannel = channel;
        mAlgo = algo;
        mRedThreshold = redThreshold;
        mHeight = height;
        mGraphLine = graphLine;
        mUseSSE = useSSE;
        mCalculateConvolution = calculateConvolution;
        mCalibrationMode = calibrationMode;
        mCornerScore = cornerScore;
        mHarrisApperture = harrisApperture;
    }

    bool operator ==(const ScannerParameters &other) const 
    {
        if ( !(this->mChannel == other.mChannel)) return false;
        if ( !(this->mAlgo == other.mAlgo)) return false;
        if ( !(this->mRedThreshold == other.mRedThreshold)) return false;
        if ( !(this->mHeight == other.mHeight)) return false;
        if ( !(this->mGraphLine == other.mGraphLine)) return false;
        if ( !(this->mUseSSE == other.mUseSSE)) return false;
        if ( !(this->mCalculateConvolution == other.mCalculateConvolution)) return false;
        if ( !(this->mCalibrationMode == other.mCalibrationMode)) return false;
        if ( !(this->mCornerScore == other.mCornerScore)) return false;
        if ( !(this->mHarrisApperture == other.mHarrisApperture)) return false;
        return true;
    }
    friend std::ostream& operator << (std::ostream &out, ScannerParameters &toSave)
    {
        corecvs::PrinterVisitor printer(out);
        toSave.accept<corecvs::PrinterVisitor>(printer);
        return out;
    }

    void print ()
    {
        std::cout << *this;
    }
};
#endif  //SCANNER_PARAMETERS_H_
