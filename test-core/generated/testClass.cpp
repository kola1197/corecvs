/**
 * \file testClass.cpp
 * \attention This file is automatically generated and should not be in general modified manually
 *
 * \date MMM DD, 20YY
 * \author autoGenerator
 * Generated from test.xml
 */

#include <vector>
#include <stddef.h>
#include "testClass.h"

/**
 *  Looks extremely unsafe because it depends on the order of static initialization.
 *  Should check standard if this is ok
 *
 *  Also it's not clear why removing "= Reflection()" breaks the code;
 **/

namespace corecvs {
#if 0
template<>
Reflection BaseReflection<TestClass>::reflection = Reflection();
template<>
int BaseReflection<TestClass>::dummy = TestClass::staticInit();
#endif
} // namespace corecvs 

SUPPRESS_OFFSET_WARNING_BEGIN


using namespace corecvs;

int TestClass::staticInit(corecvs::Reflection *toFill)
{
    if (toFill == NULL || toFill->objectSize != 0) {
        SYNC_PRINT(("staticInit(): Contract Violation in <TestClass>\n"));
         return -1;
    }

    toFill->name = ReflectionNaming(
        "Test Class",
        "Test Class with no practical use",
        ""
    );

     toFill->objectSize = sizeof(TestClass);
     

    BoolField* field0 = new BoolField
        (
          TestClass::BOOL_FIELD_ID,
          offsetof(TestClass, mBoolField),
          false,
          "Bool Field",
          "Bool Field",
          "Bool Field"
        );
    field0->widgetHint=BaseField::CHECK_BOX;
    toFill->fields.push_back(field0);
    /*  */ 
    IntField* field1 = new IntField
        (
          TestClass::INT_FIELD0_ID,
          offsetof(TestClass, mIntField0),
          0,
          "Int Field0",
          "Int Field0",
          "Int Field0"
        );
    toFill->fields.push_back(field1);
    /*  */ 
    IntField* field2 = new IntField
        (
          TestClass::INT_FIELD1_ID,
          offsetof(TestClass, mIntField1),
          0,
          "Int Field1",
          "Int Field1",
          "Int Field1",
          true,
         -5,
         5,
         1
        );
    toFill->fields.push_back(field2);
    /*  */ 
    IntField* field3 = new IntField
        (
          TestClass::INT_FIELD2_ID,
          offsetof(TestClass, mIntField2),
          0,
          "Int Field2",
          "Int Field2",
          "Int Field2"
        );
    field3->prefixHint="/";
    field3->suffixHint="%";
    toFill->fields.push_back(field3);
    /*  */ 
    DoubleField* field4 = new DoubleField
        (
          TestClass::DOUBLE_FIELD0_ID,
          offsetof(TestClass, mDoubleField0),
          2,
          "Double field0",
          "Double field0",
          "Double field0"
        );
    field4->widgetHint=BaseField::SPIN_BOX;
    field4->precision=2;
    toFill->fields.push_back(field4);
    /*  */ 
    DoubleField* field5 = new DoubleField
        (
          TestClass::DOUBLE_FIELD1_ID,
          offsetof(TestClass, mDoubleField1),
          1,
          "Double field1",
          "Double field1",
          "Double field1"
        );
    field5->widgetHint=BaseField::SLIDER;
    field5->precision=2;
    toFill->fields.push_back(field5);
    /*  */ 
    StringField* field6 = new StringField
        (
          TestClass::STRING_FIELD_ID,
          offsetof(TestClass, mStringField),
          "Test string field",
          "String field",
          "String field",
          "String field"
        );
    toFill->fields.push_back(field6);
    /*  */ 
    WStringField* field7 = new WStringField
        (
          TestClass::WSTRING_FIELD_ID,
          offsetof(TestClass, mWStringField),
          L"\u0054\u0065\u0073\u0074\u0020\u3053\u3093\u306b\u3061\u306f\u0020\u00c4\u00e4\u00cb\u00eb\u1e26\u1e27\u00cf\u00ef\u004e\u0308\u006e\u0308\u00d6\u00f6\u0054\u0308\u1e97\u00dc\u00fc\u1e72\u1e73\u1e84\u1e85\u1e8c\u1e8d\u0178\u00ff",
          "WString field",
          "WString field",
          "WString field"
        );
    toFill->fields.push_back(field7);
    /*  */ 
    EnumField* field8 = new EnumField
        (
          TestClass::ENUM_FIELD0_ID,
          offsetof(TestClass, mEnumField0),
          0,
          "Enum Field0",
          "Enum Field0",
          "Enum Field0",
          new EnumReflection(3
          , new EnumOption(0,"item1")
          , new EnumOption(1,"item2")
          , new EnumOption(2,"itemWithIcon",":/new/colors/colors/color_red.png@main.qrc")
          )
        );
    field8->widgetHint=BaseField::COMBO_BOX;
    toFill->fields.push_back(field8);
    /*  */ 
    EnumField* field9 = new EnumField
        (
          TestClass::ENUM_FIELD1_ID,
          offsetof(TestClass, mEnumField1),
          0,
          "Enum Field1",
          "Enum Field1",
          "Enum Field1",
          new EnumReflection(3
          , new EnumOption(0,"item1")
          , new EnumOption(1,"item2")
          , new EnumOption(2,"itemWithIcon",":/new/colors/colors/color_red.png@main.qrc")
          )
        );
    field9->widgetHint=BaseField::TAB_WIDGET;
    toFill->fields.push_back(field9);
    /*  */ 
    double mVectorField0_dv[] = {0,0};
    DoubleVectorField* field10 = new DoubleVectorField
        (
          TestClass::VECTOR_FIELD0_ID,
          offsetof(TestClass, mVectorField0),
          vector<double>(mVectorField0_dv, mVectorField0_dv + 2),
          2,
          "Vector Field0",
          "Vector Field0",
          "Vector Field0"
        );
    field10->precision=2;
    toFill->fields.push_back(field10);
    /*  */ 
    double mVectorField1_dv[] = {4,8};
    DoubleVectorField* field11 = new DoubleVectorField
        (
          TestClass::VECTOR_FIELD1_ID,
          offsetof(TestClass, mVectorField1),
          vector<double>(mVectorField1_dv, mVectorField1_dv + 2),
          2,
          "Vector Field1",
          "Vector Field1",
          "Vector Field1"
        );
    field11->precision=2;
    toFill->fields.push_back(field11);
    /*  */ 
    CompositeField* field12 = new CompositeField
        (
          TestClass::SUBCLASS_FIELD_ID,
          offsetof(TestClass, mSubclassField),
          "Subclass Field",
          "TestSubClass",
          "Subclass Field",
          "Subclass Field",
           NULL
        );
    {
        ReflectionDirectory* directory = ReflectionDirectoryHolder::getReflectionDirectory();
        std::string name("Test SubClass");
        ReflectionDirectory::iterator it = directory->find(name);
        if(it != directory->end()) {
             field12->reflection = it->second;
        } else {
             printf("Reflection TestClass to the subclass Test SubClass can't be linked\n");
        }
    }
    toFill->fields.push_back(field12);
    /*  */ 
    ReflectionDirectory &directory = *ReflectionDirectoryHolder::getReflectionDirectory();
    directory[std::string("Test Class")]= toFill;
   return 0;
}
int TestClass::relinkCompositeFields()
{
    {
        ReflectionDirectory* directory = ReflectionDirectoryHolder::getReflectionDirectory();
        std::string name("Test SubClass");
        ReflectionDirectory::iterator it = directory->find(name);
        if(it != directory->end()) {
             const CompositeField* field = static_cast<const CompositeField*>(getReflection()->fields[12]);
             const_cast<CompositeField*>(field)->reflection = it->second;
        } else {
             printf("Reflection TestClass to the subclass Test SubClass can't be linked\n");
        }
    }
   return 0;
}

SUPPRESS_OFFSET_WARNING_END


