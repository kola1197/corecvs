#ifndef DIS_FLOW_PARAMETERS_H_
#define DIS_FLOW_PARAMETERS_H_
/**
 * \file disFlowParameters.h
 * \attention This file is automatically generated and should not be in general modified manually
 *
 * \date MMM DD, 20YY
 * \author autoGenerator
 * Generated from opencv.xml
 */

#include "core/reflection/reflection.h"
#include "core/reflection/defaultSetter.h"
#include "core/reflection/printerVisitor.h"

/*
 *  Embed includes.
 */
/*
 *  Additional includes for Composite Types.
 */

// using namespace corecvs;

/*
 *  Additional includes for Pointer Types.
 */

// namespace corecvs {
// }
/*
 *  Additional includes for enum section.
 */

/**
 * \brief dis Flow Parameters 
 * dis Flow Parameters 
 **/
class DisFlowParameters : public corecvs::BaseReflection<DisFlowParameters>
{
public:
    enum FieldId {
        SC_F_ID,
        SC_L_ID,
        MAXITER_ID,
        MINITER_ID,
        MINDPRATE_ID,
        MINDRRATE_ID,
        MINIMGERR_ID,
        PATCHSZ_ID,
        POVERL_ID,
        USEFBCON_ID,
        PATNORM_ID,
        COSTFCT_ID,
        USETVREF_ID,
        TV_ALPHA_ID,
        TV_GAMMA_ID,
        TV_DELTA_ID,
        TV_INNERIT_ID,
        TV_SOLVERIT_ID,
        TV_SOR_ID,
        VERBOSITY_ID,
        DIS_FLOW_PARAMETERS_FIELD_ID_NUM
    };

    /** Section with variables */

    /** 
     * \brief sc_f 
     * first (coarsest) scale 
     */
    int mSc_f;

    /** 
     * \brief sc_l 
     * last (finest) scale 
     */
    int mSc_l;

    /** 
     * \brief maxiter 
     * max. iterations on one scale 
     */
    int mMaxiter;

    /** 
     * \brief miniter 
     * min. iterations on one scale 
     */
    int mMiniter;

    /** 
     * \brief mindprate 
     * minimum rate of change of delta_p before descending one level, e.g. .1 :  change scales when norm(delta_p_last)/norm(delta_p_init) < .1 
     */
    double mMindprate;

    /** 
     * \brief mindrrate 
     * minimum rate of change of residual within 3-iterations-window before descending one level, e.g. .8 :  res_new/res_old >  * .8, SET HIGH (1e10) TO DISABLE 
     */
    double mMindrrate;

    /** 
     * \brief minimgerr 
     * if (mean absolute) residual falls below this threshold, terminate iterations on current scale, IGNORES MIN_ITER , SET TO LOW (1e-10) TO DISABLE 
     */
    double mMinimgerr;

    /** 
     * \brief patchsz 
     * patch size (edge length in pixels) 
     */
    int mPatchsz;

    /** 
     * \brief poverl 
     * Patch overlap 
     */
    double mPoverl;

    /** 
     * \brief usefbcon 
     * use forward-backward flow merging 
     */
    int mUsefbcon;

    /** 
     * \brief patnorm 
     * Use patch mean-normalization 
     */
    int mPatnorm;

    /** 
     * \brief costfct 
     * Cost function: 0: L2-Norm, 1: L1-Norm, 2: PseudoHuber-Norm 
     */
    int mCostfct;

    /** 
     * \brief usetvref 
     * TV parameters 
     */
    int mUsetvref;

    /** 
     * \brief tv_alpha 
     * tv_alpha 
     */
    double mTv_alpha;

    /** 
     * \brief tv_gamma 
     * tv_gamma 
     */
    double mTv_gamma;

    /** 
     * \brief tv_delta 
     * tv_delta 
     */
    double mTv_delta;

    /** 
     * \brief tv_innerit 
     * tv_innerit 
     */
    int mTv_innerit;

    /** 
     * \brief tv_solverit 
     * tv_solverit 
     */
    int mTv_solverit;

    /** 
     * \brief tv_sor 
     * Successive-over-relaxation weight 
     */
    double mTv_sor;

    /** 
     * \brief verbosity 
     * Verbosity, 0: plot nothing, 1: final internal timing 2: complete iteration timing, (UNCOMMENTED -> 3: Display flow scales, 4: Display flow scale iterations) 
     */
    int mVerbosity;

    /** Static fields init function, this is used for "dynamic" field initialization */ 
    static int staticInit(corecvs::Reflection *toFill);

    static int relinkCompositeFields();

    /** Section with getters */
    const void *getPtrById(int fieldId) const
    {
        return (const unsigned char *)(this) + fields()[fieldId]->offset;
    }
    int sc_f() const
    {
        return mSc_f;
    }

    int sc_l() const
    {
        return mSc_l;
    }

    int maxiter() const
    {
        return mMaxiter;
    }

    int miniter() const
    {
        return mMiniter;
    }

    double mindprate() const
    {
        return mMindprate;
    }

    double mindrrate() const
    {
        return mMindrrate;
    }

    double minimgerr() const
    {
        return mMinimgerr;
    }

    int patchsz() const
    {
        return mPatchsz;
    }

    double poverl() const
    {
        return mPoverl;
    }

    int usefbcon() const
    {
        return mUsefbcon;
    }

    int patnorm() const
    {
        return mPatnorm;
    }

    int costfct() const
    {
        return mCostfct;
    }

    int usetvref() const
    {
        return mUsetvref;
    }

    double tv_alpha() const
    {
        return mTv_alpha;
    }

    double tv_gamma() const
    {
        return mTv_gamma;
    }

    double tv_delta() const
    {
        return mTv_delta;
    }

    int tv_innerit() const
    {
        return mTv_innerit;
    }

    int tv_solverit() const
    {
        return mTv_solverit;
    }

    double tv_sor() const
    {
        return mTv_sor;
    }

    int verbosity() const
    {
        return mVerbosity;
    }

    /** Section with setters */
    void setSc_f(int sc_f)
    {
        mSc_f = sc_f;
    }

    void setSc_l(int sc_l)
    {
        mSc_l = sc_l;
    }

    void setMaxiter(int maxiter)
    {
        mMaxiter = maxiter;
    }

    void setMiniter(int miniter)
    {
        mMiniter = miniter;
    }

    void setMindprate(double mindprate)
    {
        mMindprate = mindprate;
    }

    void setMindrrate(double mindrrate)
    {
        mMindrrate = mindrrate;
    }

    void setMinimgerr(double minimgerr)
    {
        mMinimgerr = minimgerr;
    }

    void setPatchsz(int patchsz)
    {
        mPatchsz = patchsz;
    }

    void setPoverl(double poverl)
    {
        mPoverl = poverl;
    }

    void setUsefbcon(int usefbcon)
    {
        mUsefbcon = usefbcon;
    }

    void setPatnorm(int patnorm)
    {
        mPatnorm = patnorm;
    }

    void setCostfct(int costfct)
    {
        mCostfct = costfct;
    }

    void setUsetvref(int usetvref)
    {
        mUsetvref = usetvref;
    }

    void setTv_alpha(double tv_alpha)
    {
        mTv_alpha = tv_alpha;
    }

    void setTv_gamma(double tv_gamma)
    {
        mTv_gamma = tv_gamma;
    }

    void setTv_delta(double tv_delta)
    {
        mTv_delta = tv_delta;
    }

    void setTv_innerit(int tv_innerit)
    {
        mTv_innerit = tv_innerit;
    }

    void setTv_solverit(int tv_solverit)
    {
        mTv_solverit = tv_solverit;
    }

    void setTv_sor(double tv_sor)
    {
        mTv_sor = tv_sor;
    }

    void setVerbosity(int verbosity)
    {
        mVerbosity = verbosity;
    }

    /** Section with embedded classes */
    /* visitor pattern - http://en.wikipedia.org/wiki/Visitor_pattern */
template<class VisitorType>
    void accept(VisitorType &visitor)
    {
        visitor.visit(mSc_f,                      static_cast<const corecvs::IntField *>(fields()[SC_F_ID]));
        visitor.visit(mSc_l,                      static_cast<const corecvs::IntField *>(fields()[SC_L_ID]));
        visitor.visit(mMaxiter,                   static_cast<const corecvs::IntField *>(fields()[MAXITER_ID]));
        visitor.visit(mMiniter,                   static_cast<const corecvs::IntField *>(fields()[MINITER_ID]));
        visitor.visit(mMindprate,                 static_cast<const corecvs::DoubleField *>(fields()[MINDPRATE_ID]));
        visitor.visit(mMindrrate,                 static_cast<const corecvs::DoubleField *>(fields()[MINDRRATE_ID]));
        visitor.visit(mMinimgerr,                 static_cast<const corecvs::DoubleField *>(fields()[MINIMGERR_ID]));
        visitor.visit(mPatchsz,                   static_cast<const corecvs::IntField *>(fields()[PATCHSZ_ID]));
        visitor.visit(mPoverl,                    static_cast<const corecvs::DoubleField *>(fields()[POVERL_ID]));
        visitor.visit(mUsefbcon,                  static_cast<const corecvs::IntField *>(fields()[USEFBCON_ID]));
        visitor.visit(mPatnorm,                   static_cast<const corecvs::IntField *>(fields()[PATNORM_ID]));
        visitor.visit(mCostfct,                   static_cast<const corecvs::IntField *>(fields()[COSTFCT_ID]));
        visitor.visit(mUsetvref,                  static_cast<const corecvs::IntField *>(fields()[USETVREF_ID]));
        visitor.visit(mTv_alpha,                  static_cast<const corecvs::DoubleField *>(fields()[TV_ALPHA_ID]));
        visitor.visit(mTv_gamma,                  static_cast<const corecvs::DoubleField *>(fields()[TV_GAMMA_ID]));
        visitor.visit(mTv_delta,                  static_cast<const corecvs::DoubleField *>(fields()[TV_DELTA_ID]));
        visitor.visit(mTv_innerit,                static_cast<const corecvs::IntField *>(fields()[TV_INNERIT_ID]));
        visitor.visit(mTv_solverit,               static_cast<const corecvs::IntField *>(fields()[TV_SOLVERIT_ID]));
        visitor.visit(mTv_sor,                    static_cast<const corecvs::DoubleField *>(fields()[TV_SOR_ID]));
        visitor.visit(mVerbosity,                 static_cast<const corecvs::IntField *>(fields()[VERBOSITY_ID]));
    }

    DisFlowParameters()
    {
        corecvs::DefaultSetter setter;
        accept(setter);
    }

    DisFlowParameters(
          int sc_f
        , int sc_l
        , int maxiter
        , int miniter
        , double mindprate
        , double mindrrate
        , double minimgerr
        , int patchsz
        , double poverl
        , int usefbcon
        , int patnorm
        , int costfct
        , int usetvref
        , double tv_alpha
        , double tv_gamma
        , double tv_delta
        , int tv_innerit
        , int tv_solverit
        , double tv_sor
        , int verbosity
    )
    {
        mSc_f = sc_f;
        mSc_l = sc_l;
        mMaxiter = maxiter;
        mMiniter = miniter;
        mMindprate = mindprate;
        mMindrrate = mindrrate;
        mMinimgerr = minimgerr;
        mPatchsz = patchsz;
        mPoverl = poverl;
        mUsefbcon = usefbcon;
        mPatnorm = patnorm;
        mCostfct = costfct;
        mUsetvref = usetvref;
        mTv_alpha = tv_alpha;
        mTv_gamma = tv_gamma;
        mTv_delta = tv_delta;
        mTv_innerit = tv_innerit;
        mTv_solverit = tv_solverit;
        mTv_sor = tv_sor;
        mVerbosity = verbosity;
    }

    /** Exact match comparator **/ 
    bool operator ==(const DisFlowParameters &other) const 
    {
        if ( !(this->mSc_f == other.mSc_f)) return false;
        if ( !(this->mSc_l == other.mSc_l)) return false;
        if ( !(this->mMaxiter == other.mMaxiter)) return false;
        if ( !(this->mMiniter == other.mMiniter)) return false;
        if ( !(this->mMindprate == other.mMindprate)) return false;
        if ( !(this->mMindrrate == other.mMindrrate)) return false;
        if ( !(this->mMinimgerr == other.mMinimgerr)) return false;
        if ( !(this->mPatchsz == other.mPatchsz)) return false;
        if ( !(this->mPoverl == other.mPoverl)) return false;
        if ( !(this->mUsefbcon == other.mUsefbcon)) return false;
        if ( !(this->mPatnorm == other.mPatnorm)) return false;
        if ( !(this->mCostfct == other.mCostfct)) return false;
        if ( !(this->mUsetvref == other.mUsetvref)) return false;
        if ( !(this->mTv_alpha == other.mTv_alpha)) return false;
        if ( !(this->mTv_gamma == other.mTv_gamma)) return false;
        if ( !(this->mTv_delta == other.mTv_delta)) return false;
        if ( !(this->mTv_innerit == other.mTv_innerit)) return false;
        if ( !(this->mTv_solverit == other.mTv_solverit)) return false;
        if ( !(this->mTv_sor == other.mTv_sor)) return false;
        if ( !(this->mVerbosity == other.mVerbosity)) return false;
        return true;
    }
    friend std::ostream& operator << (std::ostream &out, DisFlowParameters &toSave)
    {
        corecvs::PrinterVisitor printer(out);
        toSave.accept<corecvs::PrinterVisitor>(printer);
        return out;
    }

    void print ()
    {
        std::cout << *this;
    }
};
#endif  //DIS_FLOW_PARAMETERS_H_
